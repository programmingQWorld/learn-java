### Java多线程基础--对象及变量并发访问
在开发多线程程序时， 如果每个多线程处理的事情都不一样，而每个线程都互不相关，
这样开发的过程就非常轻松。但是很多时候，多线程程序是需要同时访问同一个对象，
或者变量的。这样，一个对象同时被多个线程访问，会出现处理的结果和预期不一致的可能。
因此，需要了解如何对对象及变量并发访问，写出线程安全的程序，所谓线程安全就是
处理的对象及变量的时候是同步处理的，在处理的时候其他线程是不会干扰。
本文将从以下几个角度阐述这个问题。所有的代码都在char02

1. 对于方法的同步处理
2. 对于语句块的同步处理
3. 对类枷锁的同步处理
4. 保证可见性的关键字volatile

### 对于方法的同步处理
对于一个对象的方法，如果有两个线程同时访问，如果不加控制，
访问的结果会出乎意料。所以我们需要对方法进行同步处理，让一个线程先访问，
等访问结束，在让另一个线程去访问。对于要处理的方法，用synchronized修饰该方法。
我们下面看一下对比的例子。 首先是没有同步修饰的方法，看看会有什么意料之外的事情
在这个对象中，有一个成员变量num, 如果username是a,
则num应该等于100，
如果是b，则num应该等于200，
threadA与threadB同时去访问addI方法，
预期的结果应该是a num=100 b num=200。但是实际的结果如下：
a set over!
b set over!
b  num=200
a  num=200

这是为什么呢？
因为threadA先调用addI方法，但是因为传入的参数的是a,
所示ThreadA线程休眠2s,
这是B线程也已经调用了addI方法，然后将num的值改为了200,
这是输出语句输出的是b改之后的num的值也就是200，
a的值被b再次修改覆盖了。 这个方法是线程不安全的，
我们给这个方法添加synchronized，修改如下：<br>
其他地方保持不变，现在我们在看一下，结果：<br>
a set over！<br>
a num = 100<br>
b set over!<br> 
b num = 200<br>

这个结果是不是就符合预期了呢》调用的顺序也是一致的。用synchronized可以保证多线程调用用一个对象的方法的时候，是同步进行的，注意是同一个对象，也就是说synchronized的方法是对象锁，锁住的是对象，如果是不同的对象，就没有这个线程不安全的问题。我们再上面的修改的基础上，去掉synchronized，然后修改测试方法，让两个线程调用不同对象的方法
因为userb是不需要休眠的，所以两个线程同时调用的时候，一定是B线程显出结果，这个结果是符合预期的。但是这样是无法证明synchronized是对象锁的，只能说明不同线程访问不同对象是不会出现线程不安全的情况的。再补充一个例子来证明：
同一个对象，有两个同步方法，但是线程分别调用其中一个同步方法，如果返回的结果不是同时出现的，则说明是对象锁，即锁住了一个对象，该对象的其他方法也要等该对象锁释放，才能调用。
A,B两个线程分别调用methodA与methodB, 两个方法也打印出了他们的开始和结束时间。 结果如下：


所以，对于同一个对象中的数据读与取，都需要用synchronized修饰才能同步。
脏读一定会出现在操作对象情况下，多线程"争抢"对象的结果。
 下面，说一些同步方法其他特性，当一个线程得到一个对象锁的时候，
 他再次请求对象锁，一定会再次得到该对象的锁。
 这往往出现在一个对象方法里调用这个对象的另一个方法，
 而这两个方法都是同步的。这样设计是有原因，因为如果不能再次获得这个对象锁的话，
 很容易造成死锁。这种直接获取锁的方式称之为可重入锁。
  Java中的可重入锁支持在继承中使用，也就是说可以在子类的同步方法中调用父类的同步方法。 
  下面，看个例子：
  
  结果就是i是连续输出的。这说明，当存在父子类继承关系是，子类是完全可以通过可冲入所调用父类的同步方法的。
  但是再继承关系中，同步是不会被继承的，也就是说如果父类的方法是同步的方法，然而子类再覆盖该方法的时候，没有加同步的修饰
  ，则子类的方法不算是同步方法，关于同步方法还有一点，就是同步方法出现为捕获的异常，则自动释放锁。
### 对于语句块的同步处理
对于上面的同步方法而言，其实是有些弊端的，如果同步方法是需要执行一个很长时间的任务，那么多线程再排队处理同步方法时就会等待很久，但是一个方法中，其实并不是所有的代码都需要同步处理的，只有可嫩南瓜会发生线程不安全的代码才需要同步。这时，可以擦用synchronized来修饰语句块让关键的代码进行同步。
用synchronized修饰的同步块，其格式如下：
synchronized(对象) {
    // 语句块
}
这里的对象，可以是当前类的对象this，也可以是任意的一个Object对象，或者简介继承自Object的对象，
只要保证synchronized修饰的对象被多线程访问的是同一个，而不是每次调用方法的时候都是新生成的就可以，但是特别注意String对象，
因为JVM有String常量池的原因，所以相同内容的字符串实际上就是同一个对象，在用同步语句块的时候尽可能不用String。


两个线程并发处理耗时任务只用了3s因为只在赋值的时候进行同步处理，同步语句块以外的部分都是多个线程一部处理的。
同步语句块的特性：
1. 当多个线程同时执行synchronized(x) {} 同步代码块时呈同步效果。
2. 当其他线程执行x对象中的synchronized同步方法时呈同步效果。
3. 当其他线程执行x对象中的synchronized(this)代码块时也呈现同步效果。

细说特性，首个特性不多说。第二个特性，因为同步语句块也是对象所，所有当对x加锁的时候，x对象内的同步方法也呈现同步效果，当
x为this的时候，该对象内的其他同步方法也要等待同步语句块执行完，才能执行。第三个特性和上面x为this时不一样的。第三个特定说的
是，x对象中有一个方法，该方法中有一个synchronized(this)的语句块的时候，也呈现同步效果。即A线程调用了x枷锁的同步语句块的方法，B线程在带哦用该
x对象的synchronized(this)代码块是有先后的同步关系。

上面说同步语句块比同步方法在某些方法中执行更有效率，同步语句块还有一个有点，就是如果两个方法都是同步方法，第一个方法无限
在执行的时候，第二个方法就永远不会被执行。这时可以对两个方法做同步语句块的处理，设置不同的锁对象，则可以实现两个方法异步执行。
### 对类枷锁的同步处理
### 保证可见性的关键字volatile