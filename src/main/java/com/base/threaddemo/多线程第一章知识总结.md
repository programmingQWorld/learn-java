为什么我们在examplecurrentthread内部用 currentthread()会显示构造方法的打印时main，是因为Thread.currentThread(0 返回的是代码段正在被那个线程调用的信息。这里面很显然构造方法是被main线程执行的，而run方法是被我们自己启动的线程执行的，因为没有给他起名字，所以默认是Thread-0。)

看一看继承Thread,用this调用

## 如何停止线程
### 判断线程是否终止
JDK提供了一些方法来判断线程是否种植 -- isInterrupted() 和 interrupted()

### 停止线程的方式
这个是得到线程信息中比较重要的一个方法了，因为这个和种植线程的方法相关联。先说一下种植线程的集中方式：
1. 等待run方法执行完
2. 线程对象调用stop()
3. 线程对象调用interrupt（）,在该线程的run方法中判断是否终止，抛出一个终止异常终止。
4. 线程对象用interrupt()，在该线程的run方法中判断是否终止，以retur语句结束。

第一种就不说了，第二种stop()方法已经废弃了，因为可能会产生如下原因：
1. 强制结束线程，该线程应该做的清理工作则无法完成
2. 强制结束线程，该线程已操作的加锁对象强制解锁，造成数据不一致。具体的例子可以看StopLockThread以及他的测试类StopLockThreadTest

第三种，是目前推荐的终止方法，调用interrupt，然后在run方法中判断是否终止。判断终止的方式有两种，一种是Thread类静态方法interrupted(),另一种是Thread的成员方法isInterrupted()。
着两个方法是有所区别的，第一个方法是会自动重置状态的，如果连续两次调用interrupted,第一次如果是false，第二次一定是true。而isInterrupted()是不会的。

第四种方法和第三种一样，唯一的区别就是将上面的代码中的抛出异常换成return，个人呢还是喜欢抛出异常，这里处理的形式比较多，比如打印信息，处理资源关闭或者捕捉之后再重新向上层抛出，注意一点，我们上面抛出的是InterruptedException,这里简单说一下可能产生这个异常的原因，再原有线程sleep的情况下终止线程，或者先终止线程，再让线程sleep.

### 如何暂停线程
再JDK中提供了一下两个方法用来暂停线程和恢复线程
suspend()  -- 暂停线程
resume()  -- 恢复线程

这两个方法和stop方法一样是被废弃的方法，其用法和stop一样，暴力的暂停线程和恢复线程。这两个方法之所以是废弃的主要两个原因：

1. 线程持有特定的公共资源的情况下，一旦被暂停，则公共资源无法被其他线程所持有。
2. 线程强制暂停，导致该线程执行的操作没有执行完全，这是访问该线程的数据会出现数据不一致。


### 线程的一些其他用法
线程的其他的一些基础用法如下：
1. 线程让步
2. 设置线程的优先级
3. 守护线程

#### 线程让步
JDK提供yield()方法来让线程放弃当前的CPU资源，将它让给其他的任务去占用CPU的机会，但是这也是随机的事情，有可能刚放弃资源，又马上占用时间片了。
#### 设置线程的优先级
我们可以设置线程的优先级来让CPU尽可能的将执行资源给优先级高的线程。JAVA设置了1-10这10个优先级，又有三个静态变量来提供三个优先级：
```java
/**
 * The minimum priority that a thread can have.
 */
public final static int MIN_PRIORITY = 1;
/**
* The default proority that is assigned to a thread
*/
public final static int NORM_PRIORUTY = 5;
/**
* The maximum priority that a thread can have.
*/
public final static int MAX_PRIORITY = 10,
```
我们可以通过setPriority来设置线程的优先级，可以直接传入上诉三个静态变量，也可以直接传入1-10的数字。设置后线程就会有不同的优先级。如果我们不设置优先级，
回事什么情况？线程的优先级是有继承的特性，如果我们在A线程中启动了B线程，则AB具有相同的优先级。一般我们在main线程中启动线程，就和main线程有一致的优先级。main线程的优先级默认是5.

下面说一下优先级的一些规则：
1. 优先级高的线程一般会比优先级低的线程获得更多的CPU资源，但是不带白哦优先级高的任务一定咸鱼优先级低的任务先执行完。
因为不同的线程中run方法内容可能不一样。
2. 优先级高的线程一定会比优先级低的线程执行的快。如果这两个线程是一样的run方法，但是优先级不一样，确实优先级高的线程先执行完。
#### 守护线程
JDK中提供setDaemon的方法来设置一个线程变成守护线程。守护线程的特点是其他非守护线程执行完，守护线程就自动销毁。典型的例子是GC回收器。具体可以看ExampleDaemonThread 和 ExampleDaemonThreadTest.

### 总结
这篇文章主要总结了Java线程的基本用法，关于线程安全，同步的知识，放到了第二篇。